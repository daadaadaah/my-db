# 트랜잭션

## 트랜잭션이란 무엇인가요?
- 트랜잭션이란 DBMS에서 데이터를 다루는 논리적인 작업 단위로, ACID 성질을 통해 데이터의 무결성을 보장한다.
- 또한, DBMS는 이런 트랜잭션이 ACID 성질을 통해 데이터의 무결성을 보장할 수 있도록, 다양한 기능을 제공한다.

### 데이터의 무결성이란 무엇인가요?
- 데이터베이스에 저장된 데이터의 일관성(예 : A 계좌에서 B 계좌로 100만원을 이체하는 상황이라고 했을 때, A 계좌에서는 100만원이 차감되었지만, B 계좌에는 입금이 이루어지지 않은 상태인 경우, 일관성이 깨짐)과 정확성(예 : 수량 -1인 경우 정확성 깨짐)을 지키는 것을 말한다.

## 트랜잭션이 왜 필요한가요? 또는 왜 중요한가요?
1. 여러 SQL가 원자성 있게 처리되어야 하는 경우, 데이터의 일관성을 유지하기 위해 필요하다.
2. 또한, 데이터베이스에서 데이터를 다룰 때 장애가 일어나는 경우가 있는데, 이때 트랜잭션은 데이터를 복구하는 작업의 단위가 된다.

### 만약, 트랜잭션이 없는 경우, 어떻게 되나요?


## 트랜잭션의 ACID에 대해 설명해주세요.
- ACID는 트랜잭션이 데이터베이스의 무결성을 보장할 수 있도록 하는 성질입니다.
- [https://hanamon.kr/데이터베이스-트랜잭션의-acid-성질/](https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-acid-%EC%84%B1%EC%A7%88/)
1. 원자성
    - 트랜잭션이 원자처럼 더 이상 쪼개지지 않은 하나의 프로그램 단위로 동작해야 한다는 의미이다.
    - 즉, 트랜잭션에 포함된 작은 전부 수행되거나 전부 수행되지 않아야 한다는 뜻
    - 이 원자성과 관련된 commit, rollback 기능
2. 일관성
    - 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다는 뜻
    - 예를 들면, A 계좌에서 B 계좌로 100만원을 이체하는 상황이라고 했을 때, A 계좌에서는 100만원이 차감되었지만, B 계좌에는 입금이 이루어지지 않은 상태를 말한다.
    - 또는 A 사용자에게는 재고 수량이 1로 보이고, B 사용자에게는 재고 수량이 3으로 보이는 상태
    - 이 일관성과 관련된 DBMS 기능에는 FK, PK, Lock 기능
3. 고립성
    - 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 한다는 뜻
    - 데이터베이스는 공유가 목적이기 때문에, 여러 트랜잭션이 동시에 수행된다.
    - 이때, 각 트랜잭션은 다른 트랜잭션의 방해를 받지 않고 독립적으로 작업을 수행한다.
    - 이렇게 여러 트랜잭션이 동시에 수행될 때 상호 간섭이나 데이터 충돌이 일어나지 않는 형상을 고립성이라고 한다.
    - 고립시키지 않으면 일관성이 훼손되므로!
    - 이 고립성과 관련된 DBMS 기능에는 MVCC, Lock
4. 영속성
    - 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.
    - 저장된 데이터베이스는 저장 직후 혹은 어느 때나 발생할 수 있는 정전, 장애, 오류에 영향을 받지 않아야 한다.
    - 예를 들어 은행에서 게좌이체를 성공적으로 실행한 뒤에, 해당 은행 데이터베이스에 오류가 발생해 종료되더라도 계좌이체 내역은 기록으로 남아야 한다.
    - 마찬가지로 계좌이체를 로그로 기록하기 전에 시스템 오류 등에 의해 종료가 된다면, 해당 이체 내역은 실패로 돌아가고 각 계좌들은 계좌이체 이전 상태들로 돌아가게 된다.
    - 이 고립성과 관련된 DBMS 기능에는 Redo log
  
## 트랜잭션의 격리수준에 대해 설명해주세요. 
- 크게 4가지 격리 수준이 있고, 뒤로 갈수록 격리 수준이 높습니다.
1. read uncommitted
    - 쓰기 작업 중인 트랜잭션에서 commit되지 않는 데이터가, 다른 트랜잭션에서 그 값이 보이는 수준
2. read committed
    - 쓰기 작업 중인 트랜잭션에서 commit된 데이터만 다른 트랜잭션에서 그 값이 보이는 수준
    - 이 수준은
3. repeatable read
    - 
4. serializable

### MySQL에서는 repeatable read 이여도, phantom read가 발생하지 않는데, 그 이유는 무엇인가요?



## 부정합 문제에는 어떤 것들 있나요?
- 읽기만 하는 트랜잭션이 쓰기 트랜잭션에서 작업한 중간 데이터를 읽기 때문에 발생하는 문제로, 크게 3가지가 있습니다.
1. dirty read
    - 읽기 작업을 하는 트랜잭션 1이 쓰기 작업을 하는 트랜잭션 2가 commit을 하지 않았는데, 작업한 중간 데이터를 읽기 때문에 생기는 문제다.
    - 작업 중인 트랜잭션 2가 어떤 이유로 작업을 rollback할 경우, 무효가 된 데이터를 읽게 되고 잘못된 결과를 도출한다.
    - 예를 들어, 사은품 당첨 목록에 추가되었었는데, 어떠한 이유로 rollback 된 경우, 결과적으로 사은품 당첨이 아닌데, 당첨된 걸로 나오는 경우를 말한다.
2. non-repeatable read
    - 트랜잭션 1이 데이터를 읽고, 트랜잭션 2가 데이터를 갱신, 트랜잭션 1이 다시 한번 데이터를 읽을 때, 처음 읽을 때의 결과와 동일하지 않는 현상을 말한다.
    - 예를 들어, 처음 읽을 때를 기준으로 주문을 했는데, 나중에 읽을 때에는 품절이 되었을 때?
3. phantom read
    - 트랜잭션 1이 데이터를 읽고 트랜잭션 2가 데이터를 삽입, 트랜잭션 1이 다시 한번 데이터를 읽을 때 생기는 문제이다.
    - 트랜재션 1이 읽기 작업을 다시 한번 반복할 경우, 이전에 없던 유령 데이터가 나타나는 현상을 말한다.


