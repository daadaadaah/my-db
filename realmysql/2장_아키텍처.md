# 2장 아키텍처
## 요약
- MySQL 서버는 크게 사람의 머리 역할을 하는 `MySQL 엔진`과 손발 역할을 하는 `스토리지 엔진`으로 구분할 수 있다.
- 특히, `스토리지 엔진`의 경우, 핸들러 API를 만족하면, 누구든 스토리지 엔진을 구현해서, MySQL 서버에 추가해서 사용할 수 있다.
- 여기서, `MySQL 엔진`은 클라이언트로부터 요청된 SQL문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행하고,
- `스토리지 엔진`는 실제 데이터를 Disk 스토리지에 저장하거나 Disk 스토리지로부터 데이터를 읽어오는 역할을 한다.
- 이때, MySQL 서버에서 Mysql 엔진은 1개이지만, 스토리지 엔진은 여러개를 동시에 사용할 수 있다.
- `MySQL 엔진`과 `스토리지 엔진`이 서로 통신할 때, `핸들러 API`를 사용한다.





## MySQL 엔진 아키텍처
### MySQL의 전체 구조
#### MySQL 엔진
- 클라이언트로부터 요청된 SQL문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행한다.

#### 스토리지 엔진
- 실제 데이터를 Disk 스토리지에 저장하거나 Disk 스토리지로부터 데이터를 읽어오는 역할을 한다.

#### 핸들러 API
- MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 요청할 때 사용되는 API를 말한다.
- 다음 명령어를 사용하면, 핸들러 API를 통해 얼마나 많은 데이터(레코드) 작업이 있었는지 확인할 수 있다.
```sql
mysql> show status like 'Handler%';
```



### MySQL 스레딩 구조
#### (1) 포그라운드 스레드(= 클라이언트 스레드, 사용자 스레드) 
- `포그라운드 스레드`는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.

|MyISAM 테이블|InnoDB 테이블|
|---|---|
|디스크 쓰기 작업까지 `포그라운드 스레드`가 처리함(MyISAM도 지연된 쓰기가 있지만 일방적인 방식은 아님|데이터 버퍼나 캐시까지만 `포그라운드 스레드`가 처리하고, 나머지는 버퍼로부터 디스크까지 기록하는 작업은 `백그라운드 스레드`가 처리한다.|


- `포그라운드 스레드`는 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재한다.
- 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리하고, 그렇게 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면, 해당 커넥션을 담당하던 스레드는 다시 `스레드 캐시`로 되돌아 간다.
- 이때, 이미 `스레드 캐시`에 일정 개수 이상의 대기 중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료시킨다.
- 이렇게 일정 개수의 스레드만 `스레드 캐시`에 존재하게 하고, 이는 `thread_cache_size` 시스템 변수로 `스레드 캐시에 유자할 수 있는 최대 스레드 개수`를 설정할 수 있다.

#### (2) 백그라운드 스레드 
|MyISAM 테이블|InnoDB 테이블|
|:-:|:-:|
|X|여러가지 작업이 백그라운드로 처리 된다.|
- InnoDB 중심으로 이야기한다.
- InnoDB의 경우, 다음과 같은 작업들을 백그라운드로 처리한다.
1. Insert Buffer를 병합하는 스레드
2. Disk에 Log를 기록하는 스레드
3. Disk에 InnoDB Buffer pool의 데이터를 기록하는 스레드
4. Buffer로부터 데이터를 읽어오는 스레드
5. 잠금이나 데드락을 모니터링하는 스레드
- 위의 스레드 모두 중요한 역하을 하지만, 그 중에서도 `Log 스레드`와 Disk로 버퍼의 데이터를 내려쓰는 작업을 처리하는 `Write 스레드`이다.
- `innodb_write_io_threads`와 `innodb_read_io_threads` 시스템 변수로 `데이터 쓰기 스레드`와 `데이터 읽기 스레드`의 개수를 설정할 수 있는데, MySQL 5.5버전 부터 2개 이상 지정할 수 있게 되었다.
- InnoDB에서는 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 `읽기 스레드`는 많이 설정할 필요가 없다.
- 그러나, `쓰기 스레드`는 아주 많은 작업을 백그라운드로 처리하기 때문에, 일반적인 내장 디스크를 사용할 때는 2~4 정도, DAS나 SAN과 같은 스토리지를 사용할 때는 Disk를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋다.


- 사용자의 요청을 처리하는 도중 `데이터의 쓰기 작업`은 지연(버퍼링)되어 처리될 수 있지만, `데이터의 읽기 작업`은 절대 지연될 수 없다.
- 그래서, 일반적인 상용 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재되어 있으며, InnoDB 또한 이러한 방시긍로 처리한다.
- 따라서, InnoDB에서는 INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우 데이터가 Disk의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 된다.
- 그러나, MyISAM에서는 사용자 스레드가 쓰기 작업까지 함께 처리하도록 설계되어 있어, 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.


### 메모리 할당 및 사용 구조
- MySQL에서 사용되는 메모리 공간은 크게 `글로벌 메모리 영역`과 `로컬 메모리 영역`으로 구분할 수 있다.
- 이 둘의 영역은 MySQL 서버 내에 존재하는 많은 스레드가 `공유`해서 사용하는 공간인지 여부에 따라 구분한다.

|글로벌 메모리 영역|로컬 메모리 영역|
|---|---|
|공유 O|공유 X|

#### (1) 글로벌 메모리 영역
- 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당된다.
- 운영체제의 종류에 따라 다르겠지만 요청된 메모리 공간을 100% 할당해줄 수도 있고, 그 공간만큼 예약해두고 필요할 때 조금씩 할당해주는 경우도 있다.
- MySQL의 시스템 변수로 설정해 둔 만큼, 운영체제로부터 메모리를 할당받는다고 생각해도 된다. 



#### (2) 로컬 메모리 영역(= 세션 메모리 영역)
- MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다.
- 클라이언트가 MySQL 서버에 접속하면 MySQL 서버에서는 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당하게 되는데, 클라이언트 스레드가 사용하는 메모리 공간이라고 해서 `클라이언트 메몸리 영역`이라고도 한다.
- 클라이언트와 MySQL 서버와의 커넥션을 `세션`이라고 하기 때문에, 로컬 메모리 영역을 `세션 메모리 영역`이라고도 표현한다.


### 플러그인 스토리지 엔진 모델



### 컴포넌트
- MySQL 8.0 부터는 기존의 플러그인 아키텍처를 대체하기 위해 `컴포넌트 아키텍처`가 지원된다.
- `컴포넌트`는 다음과 같은 `MySQL 서버 플러그인`의 단점을 보안해서 구현되었다.

1. 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
2. MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안 됨)
3. 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

- 컴포넌틑 사용방법은 다음과 같고, 컴포넌트를 설치하면서 새로운 시스템 변수를 설정해야 할 수도 있으니, 메뉴얼 참고!
```sql
# validate_password 컴포넌트 설치
mysql> INSTALL COMPONENT 'file://component_validate_password';

# 설치된 컴포넌트 확인
mysql> SELECT * FROM mysql.component;
```
<img width="469" alt="스크린샷 2023-10-21 오후 5 37 58" src="https://github.com/daadaadaah/my-db/assets/60481383/b43a5241-46db-4fa6-b307-81e1f21b3bfb">

```sql
# validate_password 컴포넌에서 제공하는 시스템 변수 확인
mysql> SHOW GLOBAL VARIABLES LIKE 'validate_password%';
```
<img width="441" alt="스크린샷 2023-10-21 오후 5 38 11" src="https://github.com/daadaadaah/my-db/assets/60481383/15b556df-bf9f-4677-9411-1ce2264276aa">

- 참고로, 비밀번호 검증 기능이 MySQL 5.7 버전까지는 플러그인 형태로 제공되었지만, MySQL 8.0부터는 컴포너트로 개선되었다.



### 쿼리 실행 구조
<img width="500" alt="스크린샷 2023-10-21 오후 5 44 41" src="https://github.com/daadaadaah/my-db/assets/60481383/c3bd1584-04f0-456b-bf0a-44b0995d812d">

#### (1) 쿼리 파서
- 쿼리 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해서 트리 형태의 구조로 만들어 내는 작업을 의미한다.
- 여기서, '토큰'은 MySQL이 인식할 수 있는 최소 단위의 어휘나 기호를 말한다.
- 쿼리 문장의 기본 문법 오류는 이 과정에서 발견되고 사용자에게 오류 메시지를 전달하게 된다.

#### (2) 전처리기
- 쿼리 파서는 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인하는 단계였다.
- 이 단계에서는 각 토큰을 테이블 이름이나 컬럼 이름, 또는 내장 함수와 같은 개체를 매핑해, 해당 객체의 존재 여부와 각체의 접근 권한 등을 확인하는 과정을 수행한다.
- 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러진다.

#### (3) 옵티마이저 (DBMS의 두뇌)
- 옵티마이저란 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할을 담당한다. 

#### (4) 실행 엔진 (DBMS의 손과발)
- 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를, 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.
- 예를 들어, 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 결정해보자.
- 그러면 실행 엔진은 다음과 같은 작업을 수행한다.
1. 




#### (5) 핸들러(= 스토리지 엔진, DBMS의 손과발)
- 핸들러는 MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고, 디스크로부터 읽어오는 역할을 한다.
- 핸들러는 결국 스토리지 엔진을 의미하며, MyISAM 테이블을 조작하는 경우에는 핸들러가 MyISAM 스토리지 엔진이 되고, InnoDB 테이블을 조작하는 경우에는 핸들러가 InnoDB 스토리지 엔진이 된다.

### 복제(2권에서 더 자세히!)

### 쿼리 캐시(MySQL 8.0부터 삭제된 기능)

### 스레드 풀
|MySQL 서버 엔터프라이즈 에디션|Percona Server|MySQL 서버 커뮤니티 에디션|
|---|---|---|
|Thread Pool 제공 O(내장)|Thread Pool 제공 O(플러그인 형태)|Thread Pool 제공 X|

> 만약, MySQL 커뮤니티 에디션에서도 Thread Pool 기능을 사용하고자 한다면, 동일 버전의 Percona Server에서 스레드 풀 플러그인 라이브러리를 MySQL 커뮤니티 에디션 서버에 설치해서 사용하면 된다.

- Thread Pool은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다하더라도, MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적이다.


- Thread Pool은 동시에 실행 중인 스레들들을 CPU가 최대한 잘 처리해낼 수 있는 수준으로 줄여서 빨리 처리하게 하는 기능이기 때문에, 스케줄링 과정에서 CPU 시간을 제대로 확보하지 못하는 경우에는 쿼리 처리가 더 느려지는 사례도 발생할 수 있다는 점을 주의해야 한다.
- 물론, 제한된 수의 스레드만으로 CPU가 처리하도록 적절히 유도한다면, CPU의 프로세서 친화도도 높이고, 운영체제 입장에서는 불필요한 Context switching를 줄여서 오버헤드를 낮출 수 있다.
- 




- Percona Server의 스레드 풀은 기본적으로 CPU 코어의 개수만큼 스레드 그룹을 생성한다.
- 스레드 그룹의 개수는 `thread_pool_size` 시스템 변수로 조정할 수 있다.
- 그런데, 일반적으로 CPU 코어의 갯수와 맞추는게 CPU 프로세서 친화도를 높으는데 좋다.
- 





### 트랜잭션 지원 메타 데이터
- 데이터베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보를 `데이터 딕셔너리` 또는 `메타데이터`라고 한다.
- MySQL 5.6 버전까지 테이블의 구조를 `FRM 파일`에 저장하고, 일부 스토어드 프로그램 또한 파일(*.TRN, *.TRG, *.PAR, ...)기반으로 관리했다.
- 하지만, 이런 파일 기반의 메타 데이터는 생성 및 변경 작업이 트랜잭션을 지원하지 않기 때문에, 테이블의 생성 또는 변경 도중에 MySQL 서버가 비정상적으로 종료되면, 일관되지 않은 상태로 남는 문제가 있었다.
- 이러한 문제점을 해결 하기 위해, MySQL 8.0 버전부터는 테이블의 구조 정보나 스토어드 프로그램의 코드 관련 정보를 모두 `InnoDB`의 테이블에 저장하도록 개선되었다.
- 즉, MySQL 8.0 부터는 시스템 테이블을 모두 InnoDB 스토리지 엔진을 사용하도록 개선했으며, 시스템 테이블과 데이터 딕셔너리 정보를 모두 모아서 mysql DB에 저장하고 있다.
- 



## InnoDB 스토리지 엔진 아키텍처
<img width="604" alt="스크린샷 2023-10-21 오후 6 27 48" src="https://github.com/daadaadaah/my-db/assets/60481383/ec7b3414-bde9-4e95-bd00-7cdcdb41b2a4">

- InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.
- InnoDB 스토리지 엔진의 주요 특징
1. PK에 의한 클러스터링
2. FK 지원
3. MVCC
4. 잠금 없는 일관된 읽기
5. 자동 데드락 감지
6. 자동화된 장애 복구 
- InnoDB의 구성요소(?)
1. InnoDB 버퍼 풀
2. Undo
3. Redo




### 프라이머리 키에 의한 클러스터링
|MyISAM|InnoDB|
|:-:|:-:|
|X|O|
#### InnoDB
- 


#### MyISAM



### 외래키 지원
|Memory|MyISAM|InnoDB|
|:-:|:-:|:-:|
|X|X|O|




### MVCC(Multi Version Concurrency Content, 다중 버전 동시성 제어)
- MVCC는 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이다.
- MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있다.
- InnoDB는 Undo 로그를 이용해 이 기능을 구현한다.
- 여기서, `멀티 버전`이라 함은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미이다.
- 격리 수준이 READ_COMMITTED인 MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블의 데이터 변경을 어떻게 처리하는지 살펴보자.
- 다음처럼 INSERT 문이 실행되면,

```sql
CREATE TABLE member (
	m_id INT NOT NULL,
	m_name VARCHAR(20) NOT NULL,
	m_area VARCHAR(100) NOT NULL,
	PRIMARY KEY (m_id),
	INDEX ix_area (m_area)
);

INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');
COMMIT;
```

- DB 상태는 아래 그림과 같을 것이다.
<img width="414" alt="스크린샷 2023-10-22 오전 12 42 20" src="https://github.com/daadaadaah/my-db/assets/60481383/a00bc635-2590-4188-98d0-f66b21052c13">

- 위 상태에서 다음처럼 UNDATE 문을 실행하면,
  
```sql
UPDATE member SET m_area='경기' WHERE m_id=12;
```

- DB 상태는 아래 그림과 같을 것이다.
<img width="414" alt="스크린샷 2023-10-22 오전 12 44 38" src="https://github.com/daadaadaah/my-db/assets/60481383/d4096c85-fff3-4ed4-92c5-d9f02937628d">

- 즉, commit 실행 여부와 관계 없이 InnoDB의 버퍼 풀은 새로운 값인 `경기`로 업데이트된다.
- 그리고, 디스크의 데이터 파일에는 체크포인트나 InnoDB의 Write 스레드에 의해 새로운 값으로 업데이트되어 있을 수도 있고 아닐 수도 있다.
  (InnoDB가 ACID를 보장하기 때문에 일반적으로는 InnoDB의 버퍼 풀과 데이터 파일은 동일한 상태라고 가정해도 무방하다.)
- 아직 COMMIT이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 작업 중인 레코드를 조회하는 쿼리를 날리면, 어디에 있는 데이터가 조회될까?
- 정답은 MySQL 서버의 시스템 볌수에 설정된 격리 수준에 따라 다르다.
- 격리 수준이 `READ_UNCOMMITTED`인 경우, InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환한다.
- 반면, `READ_COMMITTED`나 그 이상의 격리 수준(REPEATABLE_READ, SERIALIZABLE)인 경우에는 아직 커밋되지 않았기 때문에, 변경 이전의 내용을 보관하고 있는 Undo 영역의 데이터를 반환한다.
- 이렇게, 1개의 레코드에 대해 여러 개(2개)의 버전(변경 전/변경 후)이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조다.
- 여기서는 1개의 데이터만 가지고 설명했지만, 관리해야 하는 예전 버전의 데이터는 무한히 많아질 수 있다.
  (트랜잭션이 길어지면 Undo에서 관리하는 예전 데이터가 삭제되지 못하고 오랫동안 관리되어야 하며, 자연히 Undo 영역이 저장되는 시스템 테이블스페이스의 공간이 많이 늘어나는 상황이 발생할 수도 있다)
- 지금까지 UPDATE 쿼리가 실행되면 InnoDB 버퍼풀은 즉시 새로운 데이터로 변경되고, 기존 데이터는 Undo 영역으로 복사되는 과정까지 살펴봤다.
- 이 상태에서 COMMIT 명령을 실행하면 InnoDB는 더 이상의 변경 작업 없이 지금 상태를 영구적인 데이터로 만들어 버린다.
- 그런데, ROLLBACK 명령k을 실항하면 InnoDBㅇ는 Undo 영역에 있는 백업된 데이터를 Undo 영역 -> InnoDB 버퍼 풀로 다시 복구 하고, Undo 영역의 내용을 삭제해 버린다.
- 단, COMMIT시에는 Undo 영역의 백업 데이터가 항상 바로 삭제되는 것은 아니고, 이 Undo 영역을 필요로 하는 TX가 더 이상 없을 때 비로소 삭제된다.


### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
- InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다. 이로 인해 
- 잠금을 걸지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능하다.
- 격리 수준이 (SERIALIZABLE이 아닌) READ_UNCOMMITTED나 READ_COMMITTED, REPEATABLE_READ 수준인 경우, INSERT와 연결되지 않은 순수한 읽기(SELECT) 작업은 (다른 트랜잭션의 변경 작업과 관계없이) 항상 잠금을 대기하지 않고 바로 실행된다.
- 다음 그림처럼 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도, 이 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않는다. 이를 `잠금 없는 일관되 읽기`라고 표현한다.
<img width="603" alt="스크린샷 2023-10-22 오후 1 51 28" src="https://github.com/daadaadaah/my-db/assets/60481383/c30c3773-bd19-45cc-ba97-4e877e68a5e2">

- InnoDB에서는 변경되기 전의 데이터를 읽기 위해 Undo 로그를 사용한다.
- 오랜시간 동안 활성 상태인 TX으로 인해 MySQL 서버가 느려지거나 문제가 발생할 때가 가끔 있다.
- 바로 이런한 일관된 읽기를 위해 Undo 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 발생하는 문제이다.
- 따라서, TX이 시작되었다면, 가능한 한 빨리 ROLLBACK이나 COMMIT을 통해 트랜잭션을 완료하는 것이 좋다.


### 자동 데드락 감지
- InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리한다.
- InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어서, 데드락 감지 스레드가 주기적으로 `잠금 대기 그래프`를 검사해, 교착 상태에 빠진 TX들을 찾아서, 그 중의 1개를 종료시킨다.
- 이떄, 어느 TX을 먼저 강제 종료할 것인지에 대한 판단의 기준은 `TX의 Undo Log 양`이며, Undo Log 레코드를 더 적게 가진 TX이 일반적으로 Rollback 대상이 된다.
- 왜냐하면, Rollback을 해도, Undo 처리를 해야 할 내용이 적다는 것이며, TX 강제 Rollback으로 인한 MySQL 서버의 부하도 덜 유발하기 때문이다.
- 


### 자동화된 장애 복구


- InnoDB는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘을 이용해 `MySQL 서버가 시작될 때`, 완료되지 못한 TX이나 Disk에 일부만 기록된(Partial write) 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행한다.
- InnoDB 스토리지 엔진은 매우 견고해서 데이터 파일이 손상되거나 MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않는다.
- 그런데, MySQL 서버와 무관하게, 디스크나 서버 하드웨어 이슈로 InnoDB 스토리지 엔진이 자동으로 복구를 못하는 경우도 발생할 수 있다.
- 이렇게 한 번 문제가 생기면, 복구하기가 쉽지 않다.

- InnoDB 데이터 파일은 `기본적으로 MySQL 서버가 시작될 때` 항상 자동 복구를 수행한다.
- 그런데, 이 단계에서 자동으로 복구될 수 없는 손상이 있다면, 자동 복구를 멈추고 MySQL 서버는 종료되어 버린다.
- 이때, MySQL 서버의 설정 파일에 [innodb_force_recovery](https://dev.mysql.com/doc/refman/8.0/en/forcing-innodb-recovery.html) 시스템 변수를 설정해서, MySQL 서버를 시작해야 한다.
- 이 설정값은 MySQL 서버가 시작될 때, InnoDB 스토리지 엔진이 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있게 해준다.
1. 만약, InnoDB의 `로그 파일`이 손상되었다면, 6으로 설정하고 MySQL 서버를 기동한다.
2. 만약, InnoDB 테이블의 데이터 파일이 손상되었다면, 1로 설정하고 MySQL 서버를 기동한다.
3. 만약, 어떤 부분이 문제인지 알 수 없다면, `innodb_force_recovery` 설정값을 1~6까지 변경시켜보면서 MySQL을 재시작해본다. `innodb_force_recovery` 값이 커질수록 그만큼 심각한 상황이어서 데이터 손실 가능성이 커지고 복구 가능성은 적어진다.
- 각 숫자 값으로 복구되는 장애 상황과 해결방법을 살펴보자.
- 참고로, innodb_force_recovery가 0이 아닌 복구 모드에서는 SELECT 이외의 INSERT나 UPDATE, DELETE 같은 쿼리는 수행할 수 없다.

#### 1(SRV_FORCE_IGNORE_CORRUPT)

#### 2(SRV_FORCE_NO_BACKGROUND)

#### 3(SRV_FORCE_NO_TRX_UNDO)

#### 4(SRV_FORCE_NO_IBUF_MERGE)

#### 5(SRV_FORCE_NO_UNDO_LOG_SCAN)

#### 6(SRV_FORCE_NO_LOG_REDO)



- 일단 MySQL 서버가 가동되고 InnoDB 테이블이 인식된다면, mysqldump를 이용해 데이터를 가능한 만큼 백업하고, 그 데이터로 MySQL 서버의 DB와 테이블을 다시 생성하는 것이 좋다.
- 그런데, 1~6까지 진행했음에도 MySQL 서버가 시작되지 않으면 백업을 이용해 다시 구축하는 방법밖에 없다.
- 백업이 있다면 마지막 백업으로 데이터베이스를 새로 구축하고, 바이너리 로그를 사용해 최대한 장애 시점까지의 데이터를 복구할 수도 있다.
- 마지막 풀 백업 시점부터 장애 시점까지의 바이너리 로그가 있다면, (InnoDB의 복구를 이용하는 것보다) 풀 백업과 바이너리 로그로 복구하는 편이 데이터 손실이 적을 수 있다.
- 만약, 백업은 있지만, 복제의 바이너리 로그가 없거나 손실되었다면, 마지막 백업 시점까지만 복구할 수 있다.






### InnoDB 버퍼 풀
- InnoDB 스토리지 엔진에서 가장 핵심적인 부분
- Disk의 데이터 파일이나 인덱스 정보를 메모리에 Cache해 두는 공간
- Write 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 Buffer 역할도 함. -> 일반적인 애플리케이션에서는 CRUD 중 CUD처럼 데이털르 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에, 랜덤한 Disk 작업을 발생시키는데, 이러한 변경된 데이터를 버퍼풀이 모아서 처리하면, 랜덤한 Disk 작업의 횟수를 줄일 수 있다. 	

#### 버퍼 풀의 크기 설정
- InnoDB 버퍼 풀은 `innodb_buffer_pool_size` 시스템 변수로 크기를 설정할 수 있고, 동적으로 버퍼풀의 크기를 확장할 수 있다.
- 적절히 작은 값으로 설정한 후 상황을 봐가면서 증가시키는 방법이 최적이다.
- 만약, 이미 MySQL 서버를 사용하고 있다면, 그 서버의 메모리 설정 기준으로, InnoDB 버퍼 풀의 크기를 조정하면 된다.
- 만약, 처음으로 MySQL 서버를 준비하는 상황이라면, 다음과 같은 방법으로 InnoDB 버퍼 풀 크기를 조정하면 좋다.

1. 운영체제의 전체 메모리 공간이 ~ 8GB 미만이라면, 50% 정도만 InnoDB 버퍼 풀 크기를 설정하고, 나머지 메모리 공간은 MySQL 서버와 운영체제, 그리고 다른 프로그램이 사용할 수 있는 공간으로 확보해주는 것이 좋다.  
2. 운영체제의 전체 메모리 공간이 8GB ~ 50GB 이상이라면, 초기에는 전체 메모리의 50%에서 시작해서, 조금씩 올려가면서 최적점을 찾는다.
3. 운영체제의 전체 메모리 공간이 50GB 이상 ~ 이라면, 운영체제와 다른 응용 프로그램을 위해 약 15GB ~ 30GB 정도를 남겨두고, 나머지를 InnoDB 버퍼 풀로 할당하자.

- `innodb_buffer_pool_instances` 시스템 변수를 이용해 버퍼 풀을 여러 개로 분리해서 관리할 수 있는데, 이때, 각 버퍼 풀을 `버퍼 풀 인스턴스`라고 한다.
- 기본적으로 버퍼 풀 인스턴스의 개수는 8개로 초기화된다.
- 그런데, 전체 버퍼 풀을 위한 메모리 크기가 1GB 미만이면, 버퍼 풀 인스턴스는 1개만 생성된다.
- 버퍼 풀로 할당할 수 있는 메모리 공간이 ~ 40GB 이하 수준이라면, 기본값인 8을 유지한다.
- 메모리가 크다면, 버퍼 풀 인스턴스당 5GB 정도가 되게 인스턴스 개수를 설정하는 것이 좋다.

> 전통적인 InnoDB 버퍼 풀의 경우, 버퍼 풀 `전체`를 관리하는 잠금(세마포어)으로 인해 내부 잠금 경합을 많이 유발해왔다.
> 그런데, 이러한 경함을 줄이기 위해 버퍼 풀을 `여러 개로 쪼개어` 관리할 수 있게 개선되었다.
> 버퍼 풀이 여러 개의 작은 버퍼 풀로 쪼개지면서 개별 버퍼 풀 전체를 관리하는 잠금(세마포어) 자체도 경합이 분산되는 효과를 내게 되는 것이다.

#### 버퍼 풀의 구조
- InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어, InnoDB 스토리지 엔진이 데이터를 필요로 할 떄, 해당 데이터 페이지를 읽어서, 각 조각에 저장한다.
(`innodb_page_size` 시스템 변수에 설정된)


- 버퍼 풀의 페이지 크기 조각을 관리하기 위해, InnoDB 스토리지 엔진은 크게 `Free 리스트`, `LRU 리스트`, `Flush 리스트`라는 3개의 자료 구조를 관리한다.

1. `Free 리스트`
-  InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록이며, 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.

2.`LRU(Leat Recently Used) 리스트`
- 엄밀하게 LRU와 MRU(Most Recently Used) 리스트가 결합된 형태라고 보면 된다.
- LRU 리스트를 관리하는 목적은 Disk로부터 1번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지해서 Disk 읽기를 최소화하는 것이다.
- InnoDB 스토리지 엔진에서 데이터를 찾는 과정은 다음과 같다.
  (1) 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
  	1) InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색
  	2) 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지를 검색
  	3) 버퍼 풀에 이미 데이터 페이지가 있었다면, 해당 페이지의 포인터를 MRU 방향으로 승급
  (2) 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
  (3) 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면, MRU 헤더 부분으로 이동
  (4) 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 Age가 부여되며, 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고(`Aging`), 결국 해당 페이지는 버퍼 풀에서 제거된다. 버퍼 풀의 데이터 페이지가 쿼리에 의해 사용되면, 나이가 초기화되어 다시 젊어지고 MRU의 헤더 부분으로 옮겨진다.
  (5) 필요한 데이터가 자주 접근됐다면, 해당 페이지의 인덱스 키를 `어댑티브 해시 인덱스`에 추가
  

- 그래서, 처음 1번 읽힌 데이터 페이지가 이후 자주 사용된다면, 그 데이터 페이지는 InnoDB 버퍼 풀의 MRU 영역에서 계속 살아남게 된다.
- 반대로, 거의 사용되지 않는다면 새롭게 디스크에서 읽히는 데이터 페이지들에 밀려서 LRU의 끝으로 밀려나 결국 InnoDB 버퍼 풀에서 제거될 것이다.

3. `Flush 리스트`
- Disk로 동기화되지 않은 데이터를 가진 데이터 페이지(=더티 페이지)의 변경 시점 기준의 페이지 목록을 관리한다.
- Disk에서 읽은 상태 그대로 전혀 변경이 없다면, Flush 리스트에 관리되지 않는다.
- 그런데, 일단 한 번이라도 데이터 변경이 가해진 데이터 페이지는 Flush 리스트에 관리되고, 특정 시점이 되면 Disk로 기록되어야 한다.


- `체크 포인트`는 MySQL 서버가 시작될 때 InnoDB 스토리지 엔진이 Redo 로그의 어느 부분부터 복구를 실행해야 할지 판단하는 기준점을 만드는 역할을 한다.
- 

#### 버퍼 풀과 Redo 로그 (Redo 로그 읽은 후 다시 읽어보기)


- InnoD의 버퍼 풀은 Disk에서 읽은 상태로 전혀 변경되지 않은 `Clean Page`와 CRUD 중 CUD 명령으로 변경된 데이터를 가진 `Dirty Page`를 함께 가지고 있다.


#### Buffer Pool Flush 

- InnoDB 스토리지 엔진은 Buffer Pool에서 아직 Disk로 기록되지 않은 Dirty Page들을 성능상의 악영향 없이 Disk에 동기화하기 위해 다음과 같이 2가지의 Flush 기능을 Background로 실행한다.
1. 플러시 리스트(Flush_list) 플러시
2. LRU 리스트(LRU_list) 플러시

##### 1. 플러시 리스트(Flush_list) 플러시


##### 2. LRU 리스트(LRU_list) 플러시
- InnoDB 스토리지 엔진은 새로운 페이지들을 읽어올 공간을 만들기 위해 LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거하는데, 이때 `LRU 리스트(LRU_list) 플러시 함수`가 사용된다.
- InnoDB 스토리지 엔진은 LRU 리스트의 끝부분부터 시작해서, 최대 몇개의 페이지를 스캔할지에 대해 `innodb_lru_scan_depth` 시스템 변수를 사용한다.
- InnoDB 스토리지 엔진은 이때 스캔하면서 Dirty Page는 Disk에 동기화하게 하며, Clean Page는 즉시 Free 리스트로 페이지를 옮긴다.


#### 버퍼 풀 상태 백업 및 복구

#### 버퍼 풀의 적재 내용 확인


### Double Write Buffer




### Undo 로그
- InnoDB 스토리지 엔진은 트래잭션과 격리 수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 `Undo 로그`에 별도로 백업한다.
1. 트랜잭션 보장 : 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 `변경 전 데이터`로 복구해야 하는데, 이때 Undo 로그에 백업해 둔 이전 버전의 데이터를 이용해 복구한다. 
2. 격리 수준 보장 : 특정 커넥션에서 데이터를 변경하는 도중 다른 커넥션에서 데이터를 조회하면, 트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고,Undo 로그에 백업해 둔 데이터를 읽어서 반환하기도 한다.
- Undo 로그는 InnoDB 스토리지 엔진에서 매우 중요한 역할을 담당하지만, 관리 비용도 많이 필요하다.


#### 언두 로그 모니터링
- Undo 영역은 INSERT, UPDATE< DELETE 같은 문장으로 데이터를 변경했을 때, 변경되기 전의 데이터(이전 데이터)를 보관하는 곳이다.
- 





### 체인지 버퍼

### Redo 로그 및 로그 버퍼
- Redo 로그는 TX의 4가지 요소인 ACID 중 D(Durable)에 해당하는 영속성과 가장 밀접하게 연관되어 있다.
- Redo 로그


#### Redo 로그 활성화 및 비활성화
- 




### 어댑티브 해시 인덱스
> 사용자는 `innodb_adaptive_hash_index` 시스템 변수를 이용해서 어댑티브 해시 인덱스 기능을 `활성화` 또는 `비활성화`할 수 있다.
- `어댑티브 해시 인덱스`는 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 `자동으로` 생성하는 인덱스이다.
- `어댑티브 해시 인덱스`는 B Tree 검색 시간을 줄여주기 위해 도입된 기능이다.
- InnoDB 스토리지 엔진은 자주 읽히는 데이터의 페이지의 key 값을 이용해 `해시 인덱스`를 만들고, 필요할 때마다 어댑티브 해시 인덱스를 검색해서, 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있다.
- B-Tree를 Root 노드부터 Leaf 노드까지 찾아가는 비용이 없어지고, 그만큼 CPU는 적은 일을 하지만, 쿼리의 성능은 빨라진다. 또한, 그와 동시에 컴퓨터는 더 많은 쿼리를 동시에 처리할 수 있게 된다.






### InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교










## MyISAM 스토리지 엔진 아키텍처

## MySQL 로그 파일
