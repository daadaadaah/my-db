# 5장 트랜잭션과 잠금

## 요약
- MySQL의 동시성에 영향을 미치는 Lock, 트랜잭션, 트랜잭션 격리수준에 대해 살펴보자.
- `트랜잭션`은 작업의 완전성을 보장해주는 것이다. 즉, 논리적인 작어 셋을 모두 성공적으로 처리하거나, 1개라도 실패해서 처리하지 못할 경우 원 상태로 복구해서, 작업의 일부만 적용되는 현상(Partial update)이 발생하지 않게 만들어주는 기능이다.
- 만약, 트랜잭션을 사용하지 않아서 부분 업데이트 현상이 발생하게 된다면, 테이블 데이터의 정합성을 맞추는데 상당한 리소스가 들어간다.
- 왜냐하면, 실패한 쿼리로 인해 남은 레코드를 다시 삭제하는 재처리작업이 필요할 수도 있기 때문이다.
- 만약, 실행하는 쿼리가 1개뿐이라면, 재처리 작업은 간단할 것이지만, 2개 이상이 쿼리가 실행된 경우거나 복잡한 쿼리라면 재처리 작업하는데 리소스가 많이 들어갈 것이다.
  

- `트랜잭션`과 `Lock`이 서로 비슷한 개념 같지만, `Lock`은 동시성을 제어하기 위한 기능이고 `트랜잭션`은 데이터의 정합성을 보장하기 위한 기능이다.
- `Lock`은 여러 connection에서 동시에 동일한 자원(레코드 또는 테이블)을 변경하려고 할 경우, 순서대로 1개의 시점에는 1개의 connection만 변경할 수 있게 해주는 역할이다.
- 만약, Lock을 하지 않는다면, 1개의 데이터에 여러 connection에서 동시에 변경하게 되어, 해당 데이터의 값은 예측할 수 없는 상태가 되는 문제가 발생한다.
- `트랜잭션의 격리 수준`은 1개의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨읠 의미한다.

- MySQL에서 사용되는 잠금은 `MySQL 엔진 레벨`과 `스토리지 엔진 레벨`으로 나눌 수 있다.
- `MySQL 엔진`은 MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분으로 이해하면 된다.
- `MySQL 엔진 레벨의 잠금`은 스토리지 엔진에 영향을 미치지만, `스토리지 엔진 레벨의 잠금`은 스토리지 엔진 간 상호 영향을 미치지는 않는다.

## 5.1 트랜잭션
### MySQL에서의 트랜잭션
- `트랜잭션`은 1개의 쿼리든 2개 이상의 쿼리든 관계없이 1개의 논리적인 작업 셋 자체가 100% 적용(commit시)되거나 아무것도 적용되지 않아야(rollback) 함을 보장해주는 것이다.

### 주의사항
- DBMS의 커넥션과 동일하게, 프로그램 코드에서 트랜잭션의 범위를 최소화하는 것이 좋다.
- 왜냐하면, DB 커넥션은 개수가 제한적이어서, 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션의 개수는 줄어들 것이고, 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수 있기 때문이다.
- 이로인해 DB 처리량이 줄어들기 때문에?
- 즉, 프로그램의 코드가 DB 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화해야 한다는 것이다.
- 또한, 프로그램의 코드에서 라인 수는 1~2줄이라고 하더라도, 네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다.
- 왜냐하면, DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠지는 경우가 빈번히 발생하기 때문이다.

## 5.2 MySQL 엔진의 잠금
- MySQL 엔진에서는 테이블 데이터 동기화를 위한 테이블 락 이외에도 테이블의 구조를 잠그는 `메타데이터 락`, 그리고 사용자의 필요에 맞게 사용할 수 있는 `네임드 락`이라는 잠금 기능도 제공한다.
  
### 글로벌 락
- MySQL에서 제공하는 잠금 가운데 가장 범위가 크며, 글로벌 락이 영향을 미치는 범위는 작업 대상 테이블이나 데이터베이스가 다르더라도 `MySQL 서버 전체`이다. 
- 일단 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우, 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다.
- 글로벌 락의 유즈케이스는 여러 데이터베이스에 존재하는 MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받아야 할 때이다.



- 특정 세션에서 `백업 락`을 획득하면, 모든 세션에서 다음과 같이 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없게 된다.
1. 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
2. REPAIR TABLE과 OPTIMIZE TABLE 명령
3. 사용자 관리 및 비밀번호 변경
- 반면, 백업 락은 일반적인 테이블의 데이터 변경은 허용된다.
- 



### 테이블 락

- 명시적 테이블 락

- `묵시적 테이블 락`은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.
- 


### 네임드 락
- `네임드 락`은 `GET_LOCK()` 함수를 이용해 `임의의 문자열`에 대해 잠금을 설정할 수 있다. (AUTO_INCREMENT와 같은 데이터베이스 객체, 테이블, 레코드 X)
- 네임드 락은 단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금이다.
- 네임드 락은 자주 사용되지 않는다.
- 예를 들어, DB 서버 1대에 5대의 웹 서버가 접속해서 서비스하는 상황에서 5대의 웹 서버가 어떤 정보를 동기화해야 하는 요건처럼, 여러 클라이언트가 상호 동기화를 처리해야 할 때, 네임드 락을 이용하면 쉽게 해결할 수 있다.
- 또한, 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용할 수 있다.
- 


### 메타데이터 락


## 5.3 InnoDB 스토리지 엔진 잠금
### 5.3.1 InnoDB 스토리지 엔진의 잠금

#### 레코드 락
- 레코드 자체만을 잠그는 것을 `레코드 락`이라고 한다.
- 다른 상용 DBMS의 레코드 락과 동일한 역할을 하지만, 1가지 차이점은 InnoDB 스토리지 엔진은 (레코드 자체가 아니라) 인덱스의 레코드를 잠근다는 것이다. 
- 인덱스가 하나도 없는 테이블이더라도, 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.
- InnoDB에서는 대부분 `보조 인덱스`를 이용한 변경 작업은 `넥스트 키 락` 또는 `갭 락`을 사용하지만, `PK` 또는 `유니크 인덱스`에 의한 변경 작업에서는 (갭에 대해서는 잠그지 않고) 레코드 자체에 대해서만 락을 건다.

#### 갭 락
- `갭 락`은 (레코드 자체가 아니라) 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.
- 갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(Insert)되는 것을 제어하는 것이다.
- `갭 락`은 그 자체보다는 `넥스트 키`의 일부로 자주 사용된다. 

#### 넥스트 키 락
- `넥스트 키 락`은 `레코드 락`과 `갭 락`을 합쳐 놓은 형태의 잠금을 말한다.

- InnoDB의 갭 락이나 넥스트 키락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적이다.
- 그런데, 이외로 `넥스트 키 락`과 `갭 락`으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다.
- 가능하면, 바이너리 로그 포맷을 ROW 형태로 바꿔서 `넥스트 키 락`이나 `갭 락`을 줄이는 것이 좋다.


#### 자동 증가 락
- MySQL에서는 자동 증가하는 숫자 값을 추출하기 위해 AUTO_INCREMENT라는 컬럼 속석을 제공한다.
- AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 여러 레코드가 Insert되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 한다.
- InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 AUTO_INCREMENT Lock이라고 하는 테이블 수준의 잠금을 사용한다.







### 5.3.2 엔덱스와 잠금
- InnoDB의 잠금은 (레코드를 잠그는 것이 아닐) 인덱스를 잠그는 방식으로 처리된다.
- 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.


### 5.3.3 레코드 수준의 잠금 확인 및 해제
- InnoDB 스토리지 엔진을 사용하는 테이블의 레코드 수준 잠금은 테이블 수준의 잠금보다는 조금 더 복잡한다.
- 테이블 잠금에서는 잠금의 대상이 테이블 자체이므로, 쉽게 문제의 원인이 발견되고 해결될 수 있다.
- 하지만, 레코드 수준의 잠금은 테이블의 레코드 각각에 잠금이 걸리므로, 그 레코드가 자주 사용되지 않는다면, 오랜 시간 동안 잠겨진 상태로 남아 있어도 잘 발견되지 않는다.
- 예전 버전의 MySQL서버에서는 레코드 잠금에 대한 메타 정보를 제공하지 않기 때문에, 더더욱 어려운 부분이다.
- MySQL 5.1부터는 information_schema라는 DB에서 확인 가능했다.
- MySQL 8.0 부터는 performance_schema의 테이블을 이용해 잠금과 잠금 대기 순서를 확인할 수 있다.


## 5.4 MySQL의 격리 수준
- `트랜잭션의 격리 수준`이란 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.

<img width="688" alt="스크린샷 2023-11-08 오후 8 02 30" src="https://github.com/daadaadaah/my-db/assets/60481383/160af09b-f928-4001-bb0b-8bf317a5e06a">



### READ UNCOMMITTED
- `READ UNCOMMITTED` 격리 수준은 commit이나 rollback 여부에 상관없이, 각 트랜잭션에서의 변경 내용이 다른 트랜잭션에서 보이는 수준을 말한다.
- 따라서, 이 격리 수준에서는 데이터가 나타났다 사라졌다하는 현상을 초래하는 `Dirty Read`가 발생하여, 애플리케이션 개발자와 사용자를 상당히 혼란스럽게 만든다.
- RDBMS 표준에서는 이 격리 수준을 트랜잭션의 격리수준으로 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다.

### READ COMMITTED (오라클 DBMS에서 기본적으로 사용되는 격리 수준, 온라인 서비스에서 가장 많이 선택되는 격리 수준)
- `READ COMMITTED` 격리 수준은 commit이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있는 수준을 말한다.
- 어떤 트랜잭션에서 변경한 내용이 commit되기 전까지는 다른 트랜잭션에서 그러한 변경 내역을 조회할 수 없어서, 테이블이 아닌 Undo 영역에 백업된 레코드를 가져온다.
- 이 격리 수준에서는 1개의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때에 항상 같은 결과를 가져와야 개발자와 사용자가 혼란스럽지 않은데, 다른 결과를 가져오는 `NON-REPEATABLE READ`이 발생한다.
- 이 부정합 현상은 일반적인 웹 프로그래멩서는 크게 문제가 되지 않지만, 하나의 트랜잭션에서 동일한 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수 있다.

### REPEATABLE READ
- `REPEATABLE READ` 격리 수준은 MVCC를 위해 Undo 영역에 백업된 이전 데이터를 이용해 동일한 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장한다.
- `REPEATABLE READ`이든 `READ COMMITTED`이든 MVCC를 이용해서 commit 되기 전의 데이터를 보여준다.
- 차이점은 다음과 같다.
- `Repeatable Read` 격리 수준에서 트랜잭션은 자신의 시작 시간부터 끝 시간까지 모든 데이터를 일관된 상태로 볼 수 있다. 이것은 다른 트랜잭션이 트랜잭션의 시작 이후에 커밋한 데이터를 볼 수 없음을 의미한다.
- 즉, `Repeatable Read`는 자신의 트랜잭션보다 더 큰 트랜잭션이 변경한 데이터도 볼 수 없다. 따라서 다른 트랜잭션에서 변경한 데이터를 보는 것을 막는다.
- `Read Committed` 격리 수준에서 트랜잭션은 자신의 시작 시간부터 현재까지 커밋된 데이터만 볼 수 있다. 이것은 다른 트랜잭션이 변경한 데이터가 커밋되면, 해당 데이터를 볼 수 있음을 의미한다.
- 즉, Read Committed는 Repeatable Read와는 다르게 자신의 트랜잭션보다 작은 트랜잭션이 변경한 데이터를 볼 수 있다. 이로 인해 다른 트랜잭션에서 변경한 데이터를 더 빨리 볼 수 있지만, 동시에 다른 트랜잭션에 의해 변경된 데이터를 볼 수 있어 일관성이 덜 보장된다.
- 이 격리 수준에서는 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안보였다 하는 `PHANTOM READ`라는 문제가 발생한다.
- 그러나, InnoDB 스토리지 엔진에서는 `갭 락`과 `넥스트 키 락` 덕분에 `REPEATABLE READ` 격리 수준에서도 `PHANTOM READ`라는 문제가 발생하지 않ㄴ는다.

### SERIALIZABLE
- `SERIALIZABLE` 격리 수준은 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야만 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다.
- 즉, 한 트랜재션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다.
- 이 격리 수준에서는 일반적으로 DBMS에서 일어나는 `PHANTOM READ`라는 문제가 발생하지 않는다.

> 하지만, InnoDB 스토리지 엔진에서는 `갭 락`과 `넥스트 키 락` 덕분에 `REPEATABLE READ` 격리 수준에서도 `PHANTOM READ`라는 문제가 발생하지 않으므로, 굳이 SERIALIZABLE을 사용할 필요성은 없어 보인다.












