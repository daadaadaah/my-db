# 5장 트랜잭션과 잠금

## 요약
- MySQL의 동시성에 영향을 미치는 Lock, 트랜잭션, 트랜잭션 격리수준에 대해 살펴보자.
- `트랜잭션`은 작업의 완전성을 보장해주는 것이다. 즉, 논리적인 작어 셋을 모두 성공적으로 처리하거나, 1개라도 실패해서 처리하지 못할 경우 원 상태로 복구해서, 작업의 일부만 적용되는 현상(Partial update)이 발생하지 않게 만들어주는 기능이다.
- 만약, 트랜잭션을 사용하지 않아서 부분 업데이트 현상이 발생하게 된다면, 테이블 데이터의 정합성을 맞추는데 상당한 리소스가 들어간다.
- 왜냐하면, 실패한 쿼리로 인해 남은 레코드를 다시 삭제하는 재처리작업이 필요할 수도 있기 때문이다.
- 만약, 실행하는 쿼리가 1개뿐이라면, 재처리 작업은 간단할 것이지만, 2개 이상이 쿼리가 실행된 경우거나 복잡한 쿼리라면 재처리 작업하는데 리소스가 많이 들어갈 것이다.
  

- `트랜잭션`과 `Lock`이 서로 비슷한 개념 같지만, `Lock`은 동시성을 제어하기 위한 기능이고 `트랜잭션`은 데이터의 정합성을 보장하기 위한 기능이다.
- `Lock`은 여러 connection에서 동시에 동일한 자원(레코드 또는 테이블)을 변경하려고 할 경우, 순서대로 1개의 시점에는 1개의 connection만 변경할 수 있게 해주는 역할이다.
- 만약, Lock을 하지 않는다면, 1개의 데이터에 여러 connection에서 동시에 변경하게 되어, 해당 데이터의 값은 예측할 수 없는 상태가 되는 문제가 발생한다.
- `트랜잭션의 격리 수준`은 1개의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨읠 의미한다.


## 5.1 트랜잭션
### MySQL에서의 트랜잭션
- `트랜잭션`은 1개의 쿼리든 2개 이상의 쿼리든 관계없이 1개의 논리적인 작업 셋 자체가 100% 적용(commit시)되거나 아무것도 적용되지 않아야(rollback) 함을 보장해주는 것이다.

### 주의사항
- DBMS의 커넥션과 동일하게, 프로그램 코드에서 트랜잭션의 범위를 최소화하는 것이 좋다.
- 왜냐하면, DB 커넥션은 개수가 제한적이어서, 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션의 개수는 줄어들 것이고, 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수 있기 때문이다.
- 이로인해 DB 처리량이 줄어들기 때문에?
- 즉, 프로그램의 코드가 DB 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화해야 한다는 것이다.
- 또한, 프로그램의 코드에서 라인 수는 1~2줄이라고 하더라도, 네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다.
- 왜냐하면, DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠지는 경우가 빈번히 발생하기 때문이다.

## 5.2 MySQL 엔진의 잠금

### 글로벌 락



## 5.3 InnoDB 스토리지 엔진 잠금


## 5.4 MySQL의 격리 수준
- `트랜잭션의 격리 수준`이란 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.

<img width="688" alt="스크린샷 2023-11-08 오후 8 02 30" src="https://github.com/daadaadaah/my-db/assets/60481383/160af09b-f928-4001-bb0b-8bf317a5e06a">



### READ UNCOMMITTED
- `READ UNCOMMITTED` 격리 수준은 commit이나 rollback 여부에 상관없이, 각 트랜잭션에서의 변경 내용이 다른 트랜잭션에서 보이는 수준을 말한다.
- 따라서, 이 격리 수준에서는 데이터가 나타났다 사라졌다하는 현상을 초래하는 `Dirty Read`가 발생하여, 애플리케이션 개발자와 사용자를 상당히 혼란스럽게 만든다.
- RDBMS 표준에서는 이 격리 수준을 트랜잭션의 격리수준으로 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다.

### READ COMMITTED (오라클 DBMS에서 기본적으로 사용되는 격리 수준, 온라인 서비스에서 가장 많이 선택되는 격리 수준)
- `READ COMMITTED` 격리 수준은 commit이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있는 수준을 말한다.
- 어떤 트랜잭션에서 변경한 내용이 commit되기 전까지는 다른 트랜잭션에서 그러한 변경 내역을 조회할 수 없어서, 테이블이 아닌 Undo 영역에 백업된 레코드를 가져온다.
- 이 격리 수준에서는 1개의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때에 항상 같은 결과를 가져와야 개발자와 사용자가 혼란스럽지 않은데, 다른 결과를 가져오는 `NON-REPEATABLE READ`이 발생한다.
- 이 부정합 현상은 일반적인 웹 프로그래멩서는 크게 문제가 되지 않지만, 하나의 트랜잭션에서 동일한 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수 있다.

### REPEATABLE READ
- `REPEATABLE READ` 격리 수준은 MVCC를 위해 Undo 영역에 백업된 이전 데이터를 이용해 동일한 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장한다.
- `REPEATABLE READ`이든 `READ COMMITTED`이든 MVCC를 이용해서 commit 되기 전의 데이터를 보여준다.
- 차이점은 다음과 같다.
- `Repeatable Read` 격리 수준에서 트랜잭션은 자신의 시작 시간부터 끝 시간까지 모든 데이터를 일관된 상태로 볼 수 있다. 이것은 다른 트랜잭션이 트랜잭션의 시작 이후에 커밋한 데이터를 볼 수 없음을 의미한다.
- 즉, `Repeatable Read`는 자신의 트랜잭션보다 더 큰 트랜잭션이 변경한 데이터도 볼 수 없다. 따라서 다른 트랜잭션에서 변경한 데이터를 보는 것을 막는다.
- `Read Committed` 격리 수준에서 트랜잭션은 자신의 시작 시간부터 현재까지 커밋된 데이터만 볼 수 있다. 이것은 다른 트랜잭션이 변경한 데이터가 커밋되면, 해당 데이터를 볼 수 있음을 의미한다.
- 즉, Read Committed는 Repeatable Read와는 다르게 자신의 트랜잭션보다 작은 트랜잭션이 변경한 데이터를 볼 수 있다. 이로 인해 다른 트랜잭션에서 변경한 데이터를 더 빨리 볼 수 있지만, 동시에 다른 트랜잭션에 의해 변경된 데이터를 볼 수 있어 일관성이 덜 보장된다.
- 이 격리 수준에서는 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안보였다 하는 `PHANTOM READ`라는 문제가 발생한다.
- 그러나, InnoDB 스토리지 엔진에서는 `갭 락`과 `넥스트 키 락` 덕분에 `REPEATABLE READ` 격리 수준에서도 `PHANTOM READ`라는 문제가 발생하지 않ㄴ는다.

### SERIALIZABLE
- `SERIALIZABLE` 격리 수준은 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야만 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다.
- 즉, 한 트랜재션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다.
- 이 격리 수준에서는 일반적으로 DBMS에서 일어나는 `PHANTOM READ`라는 문제가 발생하지 않는다.

> 하지만, InnoDB 스토리지 엔진에서는 `갭 락`과 `넥스트 키 락` 덕분에 `REPEATABLE READ` 격리 수준에서도 `PHANTOM READ`라는 문제가 발생하지 않으므로, 굳이 SERIALIZABLE을 사용할 필요성은 없어 보인다.
> 












