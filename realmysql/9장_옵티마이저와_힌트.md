# 9장 옵티마이저와 힌트
## 9.1 개요
### 9.1.1 쿼리 실행 절차
1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서, MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
2. SQL의 파싱 정보(파스 트리)를 확인하면서, 어떤 테이블로부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 2번째 단계에서 결졍된 테이블의 읽기 순서나 선택된 인덱스를 이용해, 스토리지 엔진으로부터 데이터를 가져온다.

#### 1단계 : SQL 파싱 단계
#### 2단계 : 최적화 및 실행계획 수립 단계
#### 3단계 : 쿼리 실행 단계

### 9.1.2 옵티마이저의 종류
- 규칙 기반 최적화는 각 테이블이나 인덱스의 통계 정보가 거의 없고, 상대적으로 느린 CPU 연산 탓에, 비용 계산 과정이 부담스럽다는 이유로 사용되던 최적화 방법이다.
- 현재 대부분의 RDBMS가 비용 기반의 옵티마이저를 채택하고 있으며, MySQL 역시 마찬가지이다.

#### 규칙 기반 최적화 방법(예전 초기 버전의 오라클 DBMS가 선택한 방법)
- 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식을 의미한다.
- 이 방식에서는 통계 정보(테이블의 레코드 건수나 칼럼값의 분포도)를 조사하지 않고 실행 계획이 수립되기 때문에, 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어낸다.
- 하지만, 사용자의 데이터는 분포도가 매우 다양하기 때문에 규칙 기반의 최적화는 이미 오래전부터 많은 DBMS에서 거의 사용되지 않는다.
 
#### 비용 기반 최적화 방법(현재 대부분의 DBMS가 선택한 방법)
- 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해, 실행 계획별 비용을 산출한다.
- 이렇게 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해, 최종적으로 쿼리를 실행한다. 

## 9.2 기본 데이터 처리
### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
- InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 Read ahead 작업이 자동으로 시작된다.
- 여기서, Read ahead 란, 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서, 요청이 오기 전에 미리 Disk에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다.
- 풀 테이블 스캔이 실행되면, 처음에는 몇 개의 데이터 페이지는 Foreground Thread가 페이지 읽기를 실행하지만, 특정 시점(`innodb_read_ahead_threshold`로 설정된 값)부터는 읽기 작업을 Background Thread로 넘긴다.
- Background Thread가 읽기를 넘겨받는 시점부터는 1번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가시킨다.
- 이때, 1번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해 둔다.
- Foreground Thread는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로, 쿼리가 상당히 빨리 처리된다.
- 일반적으로, `innodb_read_ahead_threshold`의 디폴트 설정으로도 충분하다.
- 그러나, 데이터웨어 하우스용으로 MySQL을 사용한다면, 이 옵션을 더 낮은 값으로 설정해서, 더 빨리 Read Ahead가 시작되도록 유도하는 것도 좋은 방법이다.
- Read Ahead는 풀 테이블 스캔과 풀 인덱스 스캔  동일하게 사용된다.

#### SQL 1 vs SQL 2
```sql
# SQL 1 : 풀 테이블 스캔
mysql> SELECT * FROM employees;

# SQL 2 : 풀 인덱스 스캔 -> 
mysql> SELECT COUNT(*) FROM employees;
```
- `SQL 1`는 풀 **테이블** 스캔하는 반면, `SQL 2`는 풀 **인덱스** 스캔을 한다.
- 왜냐하면, 단순히 레코드의 건수만 필요로 하는 쿼리라면, 용량이 작은 인덱스를 선택하는 것이 디스크 읽기 횟수를 줄이기 때문이다.
- 일반적으로 인덱스는 테이블의 2~3개 칼럼만으로 구성되기 때문에, 테이블 자체보다는 용량이 작아서 훨씬 빠른 처리가 가능하다.


### 9.2.2 병렬 처리
- MySQL 8.0 부터는 다음과 같은 쿼리처럼 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다.
- cf. 아직 MySQL 서버에서는 쿼리를 여러 개의 스레드를 이용해 병렬로 처리하게 하는 힌트나 옵션은 없다.
```sql
mysql> SELECT COUNT(*) FROM salaries;
```
- 이때의 병렬처리는 여러 개의 쿼리가 동시에 처리되는 것을 말하는 것이 아니라 1개의 쿼리를 여러 개의 스레드가 작업을 나누어 동시에 처리하는 것을 의미한다. 여러 개의 쿼리가 동시에 처리는 MySQL 서버가 처음 만들어질 때부터 가능했다.
- 보통 병렬처리용 스레드 개수가 늘어날수록 쿼리 처리에 걸리는 시간이 줄어든다.
```sql
mysql> SET SESSION innodb_parallel_read_threads=1;
mysql> SELECT COUNT(*) FROM salaries;
1 row in set (0.32 sec)

mysql> SET SESSION innodb_parallel_read_threads=2;
mysql> SELECT COUNT(*) FROM salaries;
1 row in set (0.20 sec)

mysql> SET SESSION innodb_parallel_read_threads=4;
mysql> SELECT COUNT(*) FROM salaries;
1 row in set (0.18 sec)

mysql> SET SESSION innodb_parallel_read_threads=8;
mysql> SELECT COUNT(*) FROM salaries;
1 row in set (0.13 sec)
```
- 하지만, 병렬처리용 스레드 개수가 아무리 늘리더라도 서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어지는 경우도 있으니 주의하자.


### 9.2.3 ORDER BY 처리(Using filesort)


#### 9.2.3.1 소트 버퍼

#### 9.2.3.2 정렬 알고리즘

#### 9.2.3.3 정렬 처리 방법

#### 9.2.3.4 정렬 관련 상태 변수

### 9.2.4 GROUP BY 처리

#### 9.2.4.1 인덱스 스캔을 이용한 GROUP BY(타이트 인덱스 스캔)
#### 9.2.4.2 루즈 인덱스 스캔을 이용한 GROUP BY
#### 9.2.4.3 임시 테이블을 사용하는 GROUP BY



### 9.2.5 DISTINCT 처리

### 9.2.6 내부 임시 테이블 활용





## 9.3 고급 최적화

## 9.4 쿼리 힌트

