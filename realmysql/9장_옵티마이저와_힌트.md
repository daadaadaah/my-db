# 9장 옵티마이저와 힌트
## 9.1 개요
### 9.1.1 쿼리 실행 절차
1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서, MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
2. SQL의 파싱 정보(파스 트리)를 확인하면서, 어떤 테이블로부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 2번째 단계에서 결졍된 테이블의 읽기 순서나 선택된 인덱스를 이용해, 스토리지 엔진으로부터 데이터를 가져온다.

#### 1단계 : SQL 파싱 단계
#### 2단계 : 최적화 및 실행계획 수립 단계
#### 3단계 : 쿼리 실행 단계

### 9.1.2 옵티마이저의 종류
- 규칙 기반 최적화는 각 테이블이나 인덱스의 통계 정보가 거의 없고, 상대적으로 느린 CPU 연산 탓에, 비용 계산 과정이 부담스럽다는 이유로 사용되던 최적화 방법이다.
- 현재 대부분의 RDBMS가 비용 기반의 옵티마이저를 채택하고 있으며, MySQL 역시 마찬가지이다.

#### 규칙 기반 최적화 방법(예전 초기 버전의 오라클 DBMS가 선택한 방법)
- 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식을 의미한다.
- 이 방식에서는 통계 정보(테이블의 레코드 건수나 칼럼값의 분포도)를 조사하지 않고 실행 계획이 수립되기 때문에, 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어낸다.
- 하지만, 사용자의 데이터는 분포도가 매우 다양하기 때문에 규칙 기반의 최적화는 이미 오래전부터 많은 DBMS에서 거의 사용되지 않는다.
 
#### 비용 기반 최적화 방법(현재 대부분의 DBMS가 선택한 방법)
- 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해, 실행 계획별 비용을 산출한다.
- 이렇게 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해, 최종적으로 쿼리를 실행한다. 

## 9.2 기본 데이터 처리
### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
- InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 Read ahead 작업이 자동으로 시작된다.
- 여기서, Read ahead 란, 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서, 요청이 오기 전에 미리 Disk에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다.
- 풀 테이블 스캔이 실행되면, 처음에는 몇 개의 데이터 페이지는 Foreground Thread가 페이지 읽기를 실행하지만, 특정 시점(`innodb_read_ahead_threshold`로 설정된 값)부터는 읽기 작업을 Background Thread로 넘긴다.
- Background Thread가 읽기를 넘겨받는 시점부터는 1번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가시킨다.
- 이때, 1번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해 둔다.
- Foreground Thread는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로, 쿼리가 상당히 빨리 처리된다.
- 일반적으로, `innodb_read_ahead_threshold`의 디폴트 설정으로도 충분하다.
- 그러나, 데이터웨어 하우스용으로 MySQL을 사용한다면, 이 옵션을 더 낮은 값으로 설정해서, 더 빨리 Read Ahead가 시작되도록 유도하는 것도 좋은 방법이다.
- Read Ahead는 풀 테이블 스캔과 풀 인덱스 스캔  동일하게 사용된다.

#### SQL 1 vs SQL 2
```sql
# SQL 1 : 풀 테이블 스캔
mysql> SELECT * FROM employees;

# SQL 2 : 풀 인덱스 스캔 -> 
mysql> SELECT COUNT(*) FROM employees;
```
- `SQL 1`는 풀 **테이블** 스캔하는 반면, `SQL 2`는 풀 **인덱스** 스캔을 한다.
- 왜냐하면, 단순히 레코드의 건수만 필요로 하는 쿼리라면, 용량이 작은 인덱스를 선택하는 것이 디스크 읽기 횟수를 줄이기 때문이다.
- 일반적으로 인덱스는 테이블의 2~3개 칼럼만으로 구성되기 때문에, 테이블 자체보다는 용량이 작아서 훨씬 빠른 처리가 가능하다.


### 9.2.2 병렬 처리
- MySQL 8.0 부터는 다음과 같은 쿼리처럼 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다.
- cf. 아직 MySQL 서버에서는 쿼리를 여러 개의 스레드를 이용해 병렬로 처리하게 하는 힌트나 옵션은 없다.
```sql
mysql> SELECT COUNT(*) FROM salaries;
```
- 이때의 병렬처리는 여러 개의 쿼리가 동시에 처리되는 것을 말하는 것이 아니라 1개의 쿼리를 여러 개의 스레드가 작업을 나누어 동시에 처리하는 것을 의미한다. 여러 개의 쿼리가 동시에 처리는 MySQL 서버가 처음 만들어질 때부터 가능했다.
- 보통 병렬처리용 스레드 개수가 늘어날수록 쿼리 처리에 걸리는 시간이 줄어든다.
```sql
mysql> SET SESSION innodb_parallel_read_threads=1;
mysql> SELECT COUNT(*) FROM salaries;
1 row in set (0.32 sec)

mysql> SET SESSION innodb_parallel_read_threads=2;
mysql> SELECT COUNT(*) FROM salaries;
1 row in set (0.20 sec)

mysql> SET SESSION innodb_parallel_read_threads=4;
mysql> SELECT COUNT(*) FROM salaries;
1 row in set (0.18 sec)

mysql> SET SESSION innodb_parallel_read_threads=8;
mysql> SELECT COUNT(*) FROM salaries;
1 row in set (0.13 sec)
```
- 하지만, 병렬처리용 스레드 개수가 아무리 늘리더라도 서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어지는 경우도 있으니 주의하자.


### 9.2.3 ORDER BY 처리(Using filesort)
- 레코드 1~2건을 가져오는 쿼리를 제외하면, 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용된다.
- 데이터 웨어 하우스처럼 대량의 데이터를 조회해서 일괄 처리하는 기능이 아니라면, 아마도 레코드 정렬 요건은 대부분의 조회 쿼리에 포함되어 있을 것이다.
- 정렬을 처리하는 방법은 `인덱스를 이용하는 방법`과 `쿼리를 실행될 때 'Filesort'라는 별도의 처리를 이용하는 방법`으로 나눌 수 있다.

#### 정렬 처리 방법 1 : 인덱스를 이용하는 방법
##### 장점
1. INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서, 순서대로 읽기만 하면 되므로 매우 빠르다.

##### 단점
1. INSERT, UPDATE, DELETE 작업시, 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다.
2. 인덱스 때문에 디스크 공간이 더 많이 필요하다.
3. 인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요하다.

#### 정렬 처리 방법 2 : 쿼리를 실행될 때 'Filesort'라는 별도의 처리를 이용하는 방법
##### 장점
1. 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로, 충분히 빠르다.
2. 인덱스를 생성하지 않아도 되므로, 인덱스를 이용할 때의 단점이 장점으로 바뀐다.

##### 단점
1. 정렬 작업이 쿼리 실행 시 처리되므로, 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.

#### 9.2.3.1 소트 버퍼
- `Sort buffer`란 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 말한다.
- `Sort buffer`는 정렬이 필요한 경우에만 할당된다.
- 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가한다.
- 이때, 최대 사용 가능한 `Sort buffer`의 공간은 시스템 변수(`sort_buffer_size`)로 설정할 수 있다.
- 쿼리의 실행이 완료되면, Sort buffer를 위한 메모리 공간은 즉시 시스템으로 반납된다.

##### 정렬해야 할 레코드의 수 < 메모리에 할당된 Sort buffer의 공간
- 메모리에 할당된 Sort buffer 만으로 정렬할 수 있어서, 아주 빠르게 정렬이 처리될 것이다.

##### 정렬해야 할 레코드의 수 > 메모리에 할당된 Sort buffer의 공간
- MySQL은 정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데, 이 과정에서 임시 저장을 위해 Disk를 사용한다.
- 메모리의 Sort buffer에서 정렬을 수행하고, 그 결과를 임시로 Disk에 기록해둔다.
- 그리고 다음 레코드를 가져와서 다시 정렬해서 반복적으로 Disk에 임시 저장한다.
- 이처럼 각 buffer 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 한다.
- 이 병합 작업을 `멀티 Merge`라고 표현하며, 수행된 머리 Merge 횟수는 `Sort_merge_passes`라는 상태 변수에 누적해서 집계된다.

> Sort buffer를 크게 설정해서, 무조건 빠른 성능을 얻을 수 없지만, Disk의 읽기와 쓰기 사용량은 줄일 수 있다.
> 그래서, MySQL 서버의 데이터가 많거나 Disk의 I/O 성능이 낮은 장비라면, Sort buffer의 크기를 더 크게 설정하는 것이 도움이 될 수도 있다.
> 하지만, Sort buffer를 너무 크게 설정하면, 서버의 메모리가 부족해져서 MySQL 서버가 메로리 부족을 겪을 수 있다.
> -> 왜냐하면, MySQL은 글로벌 메모리 영역과 세션(로컬) 메모리 영역으로 나눠서 생각할 수 있는데, 정렬을 위해 할당하는 Sort buffer는 세션 메모리 영역에 해당한다.
> 즉, Sort buffer는 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아니다.
> 따라서, 커넥션이 많으면 많을수록, 정렬 작업이 많으면 많을수록 Sort buffer로 소비되는 메모리 공간이 커짐을 의미한다.
> Sort buffer의 크기를 10MB이상으로 설정하면, 대량의 레코드를 정렬하는 쿼리가 여러 커넥션에서 동시에 실행되면서 OS는 메모리 부족 현상을 겪을 수도 있다.
> 더는 메모리 여유 공간이 없는 경우, OS의 OOM-Killer가 여유 메모리를 확보하기 위해 프로세스를 강제로 종료할 것이다.
> 그런데, OOM-Killer는 메모리를 가장 많이 사용하는 프로세스를 강제 종료하기 때문에 일반적으로 메모리를 가장 많이 사용하는 MySQL 서버가 강제 종료 1순위가 된다.
> 
> 따라서, Sort buffer의 크기는 적절히 설정하는 것이 좋다. 지금까지 경험상 일반적인 트랜잭션 처리용 MySQL 서버의 `Sort buffer` 크기는 56KB ~ 1MB 미만이 적절해 보인다.
> 만약 대량 데이터의 정렬이 필요한 경우, 해당 세션의 Sort buffer만 `일시적으로 늘려서` 쿼리를 실행하고 다시 줄이는 것도 좋은 방법이다.


#### 9.2.3.2 정렬 알고리즘
- 레코드를 정렬할 때, `정렬 기준 칼럼만` Sort buffer에 담을지(`투 패스 정렬 방식`) 또는 `레코드 전체`를 Sort buffer에 담을지(`싱글 패스 정렬 방식`)에 따라 2가지 정렬 모드로 나눌 수 있다.
- 투 패스 정렬 방식은 싱글 패스 정렬 방식 도입 전부터 사용되던 방식으로, MySQL 8.0에서도 여전히 특정 조건에서는 투 패스 정렬 방식을 사용한다.
- MySQL의 예전 정렬 방식인 투 패스 방식은 테이블을 2번 읽어야 하기 때문에, 상당히 불합리하지만, 새로운 정렬 방식인 싱글 패스는 이러한 불합리가 없다.
- 하지만, 상글 패스 정렬 방식은 더 많은 Sort buffer 공간이 필요하다.
- 즉, 대략 128KB의 정렬 버퍼를 사용한다면, 이 쿼리는 투 패스 정렬 방식에서는 대략 7,000건의 레코드를 정렬할 수 있ㅈ니만, 싱글 패스 정렬 방식에서는 그것의 반 정도밖에 정렬할 수 없다. (물론, 이것은 Sort buffer 공간의 크기와 레코드의 크기에 의존적이다.)
- 최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 주로 사용한다.
- 하지만, 최신 버전의 MySQL 서버라고 해서, 항상 싱글 패스 정렬 방식을 사용하는 것은 아니다.
- 다음의 경우에는 MySQL 서버는 싱글 패스 정렬 방식을 사용하지 못하고, 투 패스 정렬 방식을 사용한다.
경우 1. 레코드의 크기가 max_length_for_sort_data 값보다 클 때
경우 2. BLOB, TEXT 타입의 칼럼이 SELECT 대상에 포함 될 때
- 얼핏 생각해보면, 투 패스 정렬 방식이 더 빠를 것 같지만 항상 그런 것은 아니다.
- 싱글 패스 방식은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보인다.
- 반면, 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적이다.



##### 정렬 알고리즘 1 : 투 패스 정렬 방식
- 정렬 대상 컬럼과 PK 값만 Sort buffer에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 PK로 테이블을 읽어서 SELECT할 컬럼을 가져오는 정렬 방식이다.
![image](https://github.com/daadaadaah/my-db/assets/60481383/523022f1-d6ca-4373-9cee-c8670dff5242)

- 처음 employees 테이블을 읽을 때는 정렬에 필요한 first_name 컬럼과 PK인 emp_no만 읽어서 정렬을 수행했음을 알 수 있다.
- 이 정렬이 완료되면, 그 결과 순서대로 employees 테이블을 1번 더 읽어서 last_name을 가져오고, 최종적으로 그 결과를 클라이언트 쪽으로 넘기는 과정을 확인할 수 있다.


##### 정렬 알고리즘 2 : 싱글 패스 정렬 방식
- `Sort buffer`에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 컬럼 전부를 담아서 정렬을 수행하는 정렬 방식이다.
```sql
mysql> SELECT emp_no, first_name, last_name FROM employees ORDER BY first_name;
```
![image](https://github.com/daadaadaah/my-db/assets/60481383/75e9646a-cc84-46c8-a21b-dd6d8163ce31)
- 그림에서 알 수 있듯이, 처음 employees 테이블을 읽을 때 정렬에 필요하지 않은 last_name 칼럼까지 정부 읽어서, Sort buffer에 담고 정렬을 수행한다.
- 그리고 정렬이 완뢰도면, 정렬 버퍼의 내용을 그대로 클라이언트로 넘겨주는 과정을 볼 수 있다.


  




#### 9.2.3.3 정렬 처리 방법
##### 정렬 처리 방법 1 : 인덱스를 이용한 정렬

##### 정렬 처리 방법 2 : 조인의 드라이빙 테이블만 정렬

##### 정렬 처리 방법 3 : 임시 테이블을 이용한 정렬


##### 정렬 처리 방법의 성능 비교
###### 쿼리가 처리되는 방법 1 : 스트리밍 방식
###### 쿼리가 처리되는 방법 2 : 버퍼링 방식








#### 9.2.3.4 정렬 관련 상태 변수

### 9.2.4 GROUP BY 처리

#### 9.2.4.1 인덱스 스캔을 이용한 GROUP BY(타이트 인덱스 스캔)
#### 9.2.4.2 루즈 인덱스 스캔을 이용한 GROUP BY
#### 9.2.4.3 임시 테이블을 사용하는 GROUP BY



### 9.2.5 DISTINCT 처리

### 9.2.6 내부 임시 테이블 활용





## 9.3 고급 최적화

## 9.4 쿼리 힌트

